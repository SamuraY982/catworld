<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–û—Ö–æ—Ç–∞ –ñ–∞–±–∫–∏</title>
  <style>
    body {
      margin: 0;
      background: #a7e07a;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      margin: 10px;
    }

    #game {
      display: grid;
      grid-template-columns: repeat(10, 50px);
      grid-template-rows: repeat(10, 50px);
      gap: 2px;
      margin-bottom: 10px;
    }

    .cell {
      width: 50px;
      height: 50px;
      background: #68b157;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      border-radius: 6px;
      transition: 0.2s;
      position: relative;
    }

    .hole {
      background: #1f2c1e;
    }

    .fly::after {
      content: 'ü™∞';
      position: absolute;
    }

    .frog {
      background: #3a853e;
      z-index: 2;
    }

    .snake, .hedgehog, .stork {
      color: white;
    }

    .snake {
      background: #a54242;
    }

    .hedgehog {
      background: #8b5e3c;
    }

    .stork {
      background: #4455aa;
    }

    #info {
      font-size: 18px;
    }

    #timer, #lives {
      margin: 5px;
    }

    #mobile-controls {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .ctrl-row {
      display: flex;
      gap: 5px;
    }

    .btn {
      width: 50px;
      height: 50px;
      font-size: 24px;
      border: none;
      border-radius: 6px;
      background: #4caf50;
      color: white;
      cursor: pointer;
    }

    #btn-main-menu {
      margin-bottom: 20px;
      width: 150px;
      height: 40px;
      font-size: 18px;
      background: #3b7d3b;
    }
  </style>
</head>
<body>
  <h1>üê∏ –û—Ö–æ—Ç–∞ –ñ–∞–±–∫–∏</h1>
  <div id="game"></div>
  <div id="info">
    –£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span> |
    –ú—É—Ö: <span id="score">0</span> / <span id="total">0</span> |
    ‚è≥ –í—Ä–µ–º—è: <span id="timer">60</span> —Å–µ–∫ |
    ‚ù§Ô∏è –ñ–∏–∑–Ω–∏: <span id="lives">3</span>
  </div>

  <button id="btn-main-menu" class="btn">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button>

  <script>
    const size = 10;
    const holeCount = 20;
    const totalFlies = 7;

    let frogX = 5, frogY = 5;
    let flies = [], holes = [], snakes = [], hedgehogs = [], storks = [];
    let score = 0, level = 1, lives = 3, timer = 60;
    let timerInterval, snakeInterval, hedgehogInterval, storkInterval;

    const game = document.getElementById('game');
    const scoreEl = document.getElementById('score');
    const totalEl = document.getElementById('total');
    const levelEl = document.getElementById('level');
    const timerEl = document.getElementById('timer');
    const livesEl = document.getElementById('lives');

    function createGrid() {
      game.innerHTML = '';
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          game.appendChild(cell);
        }
      }
    }

    function getCell(x, y) {
      return document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
    }

    function randomCoords(exclude = [], minDist = 0) {
      let x, y, tries = 0;
      do {
        x = Math.floor(Math.random() * size);
        y = Math.floor(Math.random() * size);
        tries++;
        if (tries > 1000) break;
      } while (
        exclude.some(p => p.x === x && p.y === y) ||
        Math.abs(x - frogX) + Math.abs(y - frogY) <= minDist ||
        (Math.abs(x - frogX) <= 1 && Math.abs(y - frogY) <= 1)
      );
      return { x, y };
    }

    function isAccessible(fromX, fromY, toX, toY) {
      const visited = Array.from({ length: size }, () => Array(size).fill(false));
      const queue = [[fromX, fromY]];
      visited[fromY][fromX] = true;
      while (queue.length) {
        const [x, y] = queue.shift();
        if (x === toX && y === toY) return true;
        for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size && !visited[ny][nx]) {
            const cell = getCell(nx, ny);
            if (!cell.classList.contains('hole')) {
              visited[ny][nx] = true;
              queue.push([nx, ny]);
            }
          }
        }
      }
      return false;
    }

    function clearCell(x, y) {
      const cell = getCell(x, y);
      cell.className = 'cell';
      cell.textContent = '';
    }

    function placeFrog() {
      const cell = getCell(frogX, frogY);
      cell.classList.add('frog');
      cell.textContent = 'üê∏';
    }

    function placeFlies() {
      flies = [];
      let attempts = 0;
      while (flies.length < totalFlies && attempts < 1000) {
        const { x, y } = randomCoords([{ x: frogX, y: frogY }, ...flies]);
        if (isAccessible(frogX, frogY, x, y)) {
          flies.push({ x, y });
        }
        attempts++;
      }
      flies.forEach(f => getCell(f.x, f.y).classList.add('fly'));
      score = 0;
      scoreEl.textContent = score;
      totalEl.textContent = flies.length;
    }

    function moveFrog(dx, dy) {
      const newX = frogX + dx;
      const newY = frogY + dy;
      if (newX < 0 || newY < 0 || newX >= size || newY >= size) return;
      const target = getCell(newX, newY);
      if (target.classList.contains('hole')) return;

      clearCell(frogX, frogY);
      frogX = newX;
      frogY = newY;
      placeFrog();
      eatFly();
    }

    function eatFly() {
      const index = flies.findIndex(f => f.x === frogX && f.y === frogY);
      if (index !== -1) {
        flies.splice(index, 1);
        score++;
        scoreEl.textContent = score;
        getCell(frogX, frogY).classList.remove('fly');
        if (score >= totalFlies) nextLevel();
      }
    }

    function nextLevel() {
      clearInterval(timerInterval);
      clearInterval(snakeInterval);
      clearInterval(hedgehogInterval);
      clearInterval(storkInterval);
      level++;
      levelEl.textContent = level;
      startGame();
    }

    function placeHoles() {
      holes = [];
      for (let i = 0; i < holeCount; i++) {
        const { x, y } = randomCoords([{ x: frogX, y: frogY }, ...flies, ...holes], 1);
        holes.push({ x, y });
        getCell(x, y).classList.add('hole');
      }
    }

    function startTimer() {
      timer = 60; // —Å–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ —É—Ä–æ–≤–Ω—è
      timerEl.textContent = timer;
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timer--;
        timerEl.textContent = timer;
        if (timer <= 0) {
          clearInterval(timerInterval);
          gameOver();
        }
      }, 1000);
    }

    function gameOver() {
      alert("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!");
      location.reload();
    }

    // –í—Ä–∞–≥–∏ –∏ –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏–µ

    function spawnSnakes() {
      snakes = [];
      for (let i = 0; i < level; i++) {
        const { x, y } = randomCoords([{ x: frogX, y: frogY }, ...snakes]);
        snakes.push({ x, y });
        getCell(x, y).classList.add('snake');
        getCell(x, y).textContent = 'üêç';
      }

      clearInterval(snakeInterval);
      snakeInterval = setInterval(() => {
        snakes.forEach((snake, i) => {
          clearCell(snake.x, snake.y);

          // –¥–≤–∏–∂–µ–Ω–∏–µ –∫ –∂–∞–±–∫–µ
          let dx = frogX - snake.x;
          let dy = frogY - snake.y;
          if (Math.abs(dx) > Math.abs(dy)) {
            dx = dx > 0 ? 1 : -1;
            dy = 0;
          } else {
            dy = dy > 0 ? 1 : -1;
            dx = 0;
          }

          const newX = snake.x + dx;
          const newY = snake.y + dy;

          if (
            newX >= 0 && newX < size &&
            newY >= 0 && newY < size &&
            !getCell(newX, newY).classList.contains('hole')
          ) {
            snake.x = newX;
            snake.y = newY;
          }

          if (snake.x === frogX && snake.y === frogY) {
            loseLife();
          }

          getCell(snake.x, snake.y).classList.add('snake');
          getCell(snake.x, snake.y).textContent = 'üêç';
        });
      }, 1500);
    }

    function spawnHedgehogs() {
      hedgehogs = [];
      for (let i = 0; i < level; i++) {
        const { x, y } = randomCoords([{ x: frogX, y: frogY }, ...hedgehogs]);
        hedgehogs.push({ x, y });
        getCell(x, y).classList.add('hedgehog');
        getCell(x, y).textContent = 'ü¶î';
      }

      clearInterval(hedgehogInterval);
      hedgehogInterval = setInterval(() => {
        hedgehogs.forEach(hedgehog => {
          clearCell(hedgehog.x, hedgehog.y);

          const moves = [
            [0, 1], [0, -1], [1, 0], [-1, 0]
          ];
          const [dx, dy] = moves[Math.floor(Math.random() * moves.length)];
          const newX = hedgehog.x + dx;
          const newY = hedgehog.y + dy;

          if (
            newX >= 0 && newX < size &&
            newY >= 0 && newY < size &&
            !getCell(newX, newY).classList.contains('hole')
          ) {
            hedgehog.x = newX;
            hedgehog.y = newY;
          }

          if (hedgehog.x === frogX && hedgehog.y === frogY) {
            loseLife();
          }

          getCell(hedgehog.x, hedgehog.y).classList.add('hedgehog');
          getCell(hedgehog.x, hedgehog.y).textContent = 'ü¶î';
        });
      }, 2000);
    }

    function spawnStorks() {
      storks = [];
      for (let i = 0; i < Math.floor(level / 2); i++) {
        const { x, y } = randomCoords([{ x: frogX, y: frogY }, ...storks]);
        storks.push({ x, y });
        getCell(x, y).classList.add('stork');
        getCell(x, y).textContent = 'üïäÔ∏è';
      }

      clearInterval(storkInterval);
      storkInterval = setInterval(() => {
        storks.forEach(stork => {
          clearCell(stork.x, stork.y);

          let options = [];
          for (let dx = -2; dx <= 2; dx++) {
            for (let dy = -2; dy <= 2; dy++) {
              const x = frogX + dx;
              const y = frogY + dy;
              if (
                x >= 0 && y >= 0 && x < size && y < size &&
                !(dx === 0 && dy === 0) &&
                !getCell(x, y).classList.contains('hole')
              ) {
                options.push({ x, y });
              }
            }
          }

          const pos = options[Math.floor(Math.random() * options.length)];
          if (pos) {
            stork.x = pos.x;
            stork.y = pos.y;
          }

          if (stork.x === frogX && stork.y === frogY) {
            loseLife();
          }

          getCell(stork.x, stork.y).classList.add('stork');
          getCell(stork.x, stork.y).textContent = 'üïäÔ∏è';
        });
      }, 2200);
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
      }
    }

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª–∏–∫–æ–º –ø–æ —Å–æ—Å–µ–¥–Ω–µ–π –∫–ª–µ—Ç–∫–µ
    game.addEventListener('click', e => {
      const cell = e.target.closest('.cell');
      if (!cell) return;

      const x = parseInt(cell.dataset.x);
      const y = parseInt(cell.dataset.y);

      const dx = x - frogX;
      const dy = y - frogY;

      const isAdjacent = (Math.abs(dx) === 1 && dy === 0) || (Math.abs(dy) === 1 && dx === 0);

      if (isAdjacent && !cell.classList.contains('hole')) {
        moveFrog(dx, dy);
      }
    });

    document.getElementById('btn-main-menu').addEventListener('click', () => {
      window.location.href = 'index.html';
    });

    function startGame() {
      frogX = 5;
      frogY = 5;
      lives = 3;
      score = 0;
      levelEl.textContent = level;
      livesEl.textContent = lives;
      scoreEl.textContent = score;

      createGrid();
      placeFrog();
      placeHoles();
      placeFlies();

      startTimer();

      clearInterval(snakeInterval);
      clearInterval(hedgehogInterval);
      clearInterval(storkInterval);

      spawnSnakes();
      spawnHedgehogs();
      spawnStorks();
    }

    // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
    startGame();
  </script>
</body>
</html>
