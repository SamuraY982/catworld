<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Приключения Жабки-Охотницы</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Пользовательские стили для игры */
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2f7; /* Светло-голубой фон */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 900px;
            width: 100%;
            align-items: center;
        }

        canvas {
            background-color: #81c784; /* Цвет воды/болота */
            border: 5px solid #4caf50; /* Темно-зеленая рамка */
            border-radius: 15px;
            display: block;
            touch-action: none; /* Отключаем стандартные действия касания */
            /* Убираем фиксированные размеры, чтобы JavaScript мог их установить */
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 10px 0;
            font-size: 1.25rem;
            font-weight: bold;
            color: #388e3c; /* Темно-зеленый текст */
        }

        .game-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-button {
            background-color: #66bb6a; /* Ярко-зеленая кнопка */
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            border: none;
        }

        .game-button:hover {
            background-color: #4caf50; /* Темнее при наведении */
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        /* Модальное окно */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.visible .modal-content {
            transform: translateY(0);
        }

        .modal-content h2 {
            font-size: 2.2rem;
            color: #388e3c;
            margin-bottom: 15px;
        }

        .modal-content p {
            font-size: 1.2rem;
            color: #555;
            margin-bottom: 25px;
        }

        .modal-content button {
            background-color: #66bb6a;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            border: none;
        }

        .modal-content button:hover {
            background-color: #4caf50;
        }

        /* Адаптивные стили для мобильных устройств */
        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }
            .game-info {
                font-size: 1rem;
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
            .game-button {
                padding: 10px 20px;
                font-size: 1rem;
            }
            .modal-content h2 {
                font-size: 1.8rem;
            }
            .modal-content p {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl font-extrabold text-green-700 mb-4 text-center">Приключения Жабки-Охотницы</h1>
        <div class="game-info">
            <div id="score">Мухи: 0</div>
            <div id="level">Уровень: 1</div>
            <div id="lives">Жизни: 3</div>
        </div>
        <canvas id="gameCanvas"></canvas> <input type="file" id="hiddenFrogFileInput" accept="image/*" class="hidden">

        <div class="game-controls">
            <button id="startButton" class="game-button">Начать игру</button>
            <button id="resetButton" class="game-button hidden">Перезапустить</button>
            <button id="mainMenuButton" class="game-button hidden">Главное меню</button>
        </div>
    </div>

    <div id="gameModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
            <button id="modalCloseButton">ОК</button>
        </div>
    </div>

    <script>
        // Получаем элементы DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const livesDisplay = document.getElementById('lives');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const mainMenuButton = document.getElementById('mainMenuButton');
        const gameModal = document.getElementById('gameModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const hiddenFrogFileInput = document.getElementById('hiddenFrogFileInput'); // Получаем скрытый input file

        // Размеры игрового поля
        const GRID_SIZE = 15; // Количество квадратиков по ширине и высоте (ИЗМЕНЕНО НА 15)
        let CELL_SIZE; // Размер одного квадратика будет вычисляться динамически

        // Состояние игры
        let frog = { x: 0, y: 0, lives: 3 };
        let flies = [];
        let holes = [];
        let predators = [];
        let score = 0;
        let level = 1;
        let gameOver = false;
        let gameStarted = false;
        let predatorMovementInterval = null; // Интервал для движения хищников
        let frogImage = new Image(); // Объект изображения для жабки
        let isFrogImageLoaded = false; // Флаг для отслеживания загрузки изображения

        // --- Место для добавления URL изображения жабки ---
        // Установите URL вашего фото жабки здесь.
        // Это фото было предоставлено вами: жаб.png
        // Убедитесь, что путь к изображению правильный относительно вашего HTML файла.
        frogImage.src = '/Image/жаб.png'; // Изменено на относительный путь для локальной папки
        // --------------------------------------------------

        // Конфигурация уровней (обновлена с учетом 15x15 поля и возможностью перебалансировки)
        const levelsConfig = [
            // Уровень 1: Змеи
            { fliesToEat: 3, holes: 5, predators: [{ type: 'snake', count: 1, speed: 600 }] },
            // Уровень 2: Змеи и Ежи
            { fliesToEat: 4, holes: 7, predators: [{ type: 'snake', count: 1, speed: 550 }, { type: 'hedgehog', count: 1, speed: 650 }] },
            // Уровень 3: Змеи, Ежи, Цапли
            { fliesToEat: 5, holes: 9, predators: [{ type: 'snake', count: 1, speed: 500 }, { type: 'hedgehog', count: 1, speed: 600 }, { type: 'heron', count: 1, speed: 800 }] },
            // Уровень 4: Увеличение змей
            { fliesToEat: 4, holes: 8, predators: [{ type: 'snake', count: 2, speed: 480 }, { type: 'hedgehog', count: 1, speed: 580 }, { type: 'heron', count: 1, speed: 750 }] },
            // Уровень 5: Увеличение ежей
            { fliesToEat: 5, holes: 10, predators: [{ type: 'snake', count: 2, speed: 460 }, { type: 'hedgehog', count: 2, speed: 550 }, { type: 'heron', count: 1, speed: 700 }] },
            // Уровень 6: Увеличение цапель
            { fliesToEat: 6, holes: 12, predators: [{ type: 'snake', count: 2, speed: 440 }, { type: 'hedgehog', count: 2, speed: 520 }, { type: 'heron', count: 2, speed: 650 }] },
            // Уровень 7: Больше змей
            { fliesToEat: 5, holes: 13, predators: [{ type: 'snake', count: 3, speed: 420 }, { type: 'hedgehog', count: 2, speed: 500 }, { type: 'heron', count: 2, speed: 620 }] },
            // Уровень 8: Больше ежей
            { fliesToEat: 6, holes: 14, predators: [{ type: 'snake', count: 3, speed: 400 }, { type: 'hedgehog', count: 3, speed: 480 }, { type: 'heron', count: 2, speed: 600 }] },
            // Уровень 9: Больше цапель
            { fliesToEat: 7, holes: 15, predators: [{ type: 'snake', count: 3, speed: 380 }, { type: 'hedgehog', count: 3, speed: 460 }, { type: 'heron', count: 3, speed: 580 }] },
            // Уровень 10: Увеличение всех
            { fliesToEat: 7, holes: 16, predators: [{ type: 'snake', count: 4, speed: 360 }, { type: 'hedgehog', count: 4, speed: 440 }, { type: 'heron', count: 3, speed: 560 }] },
            // Уровень 11: Увеличение всех
            { fliesToEat: 8, holes: 17, predators: [{ type: 'snake', count: 4, speed: 340 }, { type: 'hedgehog', count: 4, speed: 420 }, { type: 'heron', count: 4, speed: 540 }] },
            // Уровень 12: Увеличение всех
            { fliesToEat: 9, holes: 18, predators: [{ type: 'snake', count: 5, speed: 320 }, { type: 'hedgehog', count: 5, speed: 400 }, { type: 'heron', count: 4, speed: 520 }] },
            // Уровень 13: Увеличение всех
            { fliesToEat: 9, holes: 19, predators: [{ type: 'snake', count: 5, speed: 300 }, { type: 'hedgehog', count: 5, speed: 380 }, { type: 'heron', count: 5, speed: 500 }] },
            // Уровень 14: Увеличение всех
            { fliesToEat: 10, holes: 20, predators: [{ type: 'snake', count: 6, speed: 280 }, { type: 'hedgehog', count: 6, speed: 360 }, { type: 'heron', count: 5, speed: 480 }] },
            // Уровень 15: Финальный вызов (максимум хищников и скорость)
            { fliesToEat: 12, holes: 22, predators: [{ type: 'snake', count: 6, speed: 250 }, { type: 'hedgehog', count: 6, speed: 320 }, { type: 'heron', count: 6, speed: 450 }] }
        ];

        // Функция для отображения модального окна
        function showModal(title, message, onConfirm = null) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            gameModal.classList.add('visible');
            modalCloseButton.onclick = () => {
                gameModal.classList.remove('visible');
                if (onConfirm) onConfirm();
            };
        }

        // Функция для настройки размера canvas и устранения "мыла"
        function setupCanvasSize() {
            const containerWidth = canvas.parentElement.clientWidth;
            // Максимальная ширина 600px, но не более 90% от ширины контейнера
            const desiredSize = Math.min(600, containerWidth * 0.9);

            // Учитываем devicePixelRatio для устранения "мыла"
            const dpi = window.devicePixelRatio || 1;
            canvas.width = desiredSize * dpi;
            canvas.height = desiredSize * dpi;
            CELL_SIZE = canvas.width / GRID_SIZE;

            // Масштабируем контекст, чтобы рисовать в логических пикселях
            ctx.scale(dpi, dpi);
            canvas.style.width = `${desiredSize}px`; // Устанавливаем отображаемые размеры
            canvas.style.height = `${desiredSize}px`;
            
            draw(); // Перерисовываем поле после изменения размера
        }

        // Функция для загрузки изображения жабки из файла (теперь не вызывается автоматически)
        function loadFrogImageFromDevice() {
            // Эта функция больше не вызывается автоматически при инициализации,
            // так как изображение теперь задается напрямую через frogImage.src.
            // Однако, если вы хотите снова использовать загрузку с устройства,
            // вы можете вызвать hiddenFrogFileInput.click() в другом месте.
            hiddenFrogFileInput.click();
        }

        // Обработчик изменения файла в input type="file" (остается для обработки выбора файла, если loadFrogImageFromDevice() будет вызвана)
        hiddenFrogFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    frogImage.src = e.target.result;
                    frogImage.onload = () => {
                        isFrogImageLoaded = true;
                        draw(); // Перерисовываем, когда изображение загружено
                    };
                    frogImage.onerror = () => {
                        isFrogImageLoaded = false; // Если ошибка, не используем изображение
                        console.error("Не удалось загрузить изображение жабки из файла.");
                        draw(); // Перерисовываем без изображения
                    };
                };
                reader.onerror = () => {
                    isFrogImageLoaded = false;
                    console.error("Ошибка чтения файла.");
                    draw();
                };
                reader.readAsDataURL(file); // Читаем файл как Data URL (Base64)
            } else {
                isFrogImageLoaded = false; // Если файл не изображение, не используем изображение
                draw();
                console.warn("Выбранный файл не является изображением.");
            }
        });

        // Инициализация игры
        function initializeGame() {
            score = 0;
            level = 1;
            frog.lives = 3;
            gameOver = false;
            gameStarted = false;
            updateGameInfo();
            resetButton.classList.add('hidden');
            mainMenuButton.classList.add('hidden'); // Скрываем кнопку "Главное меню"
            startButton.classList.remove('hidden'); // Показываем кнопку "Начать игру"
            clearInterval(predatorMovementInterval); // Очищаем интервал при инициализации
            setupCanvasSize(); // Устанавливаем размер canvas при инициализации

            // Проверяем, было ли изображение успешно загружено через frogImage.src
            frogImage.onload = () => {
                isFrogImageLoaded = true;
                draw();
            };
            frogImage.onerror = () => {
                isFrogImageLoaded = false;
                console.error("Не удалось загрузить изображение жабки по заданному URL.");
                draw(); // Перерисовываем без изображения
            };
            // Если src уже установлен, пытаемся загрузить
            if (frogImage.src && frogImage.src !== window.location.href) {
                // Если изображение уже загружено (из предыдущих попыток или кэша),
                // то onload/onerror могут не сработать, поэтому проверяем complete.
                if (frogImage.complete && frogImage.naturalWidth !== 0) {
                    isFrogImageLoaded = true;
                    draw();
                } else if (frogImage.complete && frogImage.naturalWidth === 0) {
                    isFrogImageLoaded = false;
                    console.error("Изображение жабки не загрузилось корректно (пустое).");
                    draw();
                }
                // Если изображение еще не загружено, onload/onerror сработают.
            } else {
                isFrogImageLoaded = false; // Если src не установлен, нет изображения
                draw();
            }
        }

        // Запуск игры
        function startGame() {
            gameStarted = true;
            gameOver = false;
            startButton.classList.add('hidden');
            resetButton.classList.remove('hidden');
            mainMenuButton.classList.remove('hidden'); // Показываем кнопку "Главное меню"
            loadLevel(level);
            gameLoop(); // Предполагается, что gameLoop вызывает draw()
        }

        // Загрузка уровня
        function loadLevel(levelNum) {
            if (levelNum > levelsConfig.length) {
                // Если все уровни пройдены
                showModal('Поздравляем!', 'Вы прошли все уровни! Вы настоящая жабка-охотница!', initializeGame);
                return;
            }

            const config = levelsConfig[levelNum - 1];
            
            // Генерируем поле
            generateBoard(config.holes);
            
            // Размещаем жабку в случайном безопасном месте
            placeFrogRandomly();

            // Размещаем мух
            placeFlies(config.fliesToEat);

            // Размещаем хищников
            placePredators(config.predators); // Передаем массив конфигураций хищников

            // Обновляем информацию на экране
            updateGameInfo();

            // Запускаем движение хищников
            clearInterval(predatorMovementInterval); // Очищаем предыдущий интервал
            // Вычисляем скорость самого быстрого хищника для текущего уровня
            let fastestPredatorSpeed = Infinity;
            config.predators.forEach(p => {
                if (p.speed < fastestPredatorSpeed) {
                    fastestPredatorSpeed = p.speed;
                }
            });
            // Убедимся, что fastestPredatorSpeed не Infinity, если хищников нет
            if (fastestPredatorSpeed === Infinity) {
                fastestPredatorSpeed = 1000; // Дефолтная скорость, если хищников нет
            }
            predatorMovementInterval = setInterval(movePredators, fastestPredatorSpeed);
        }

        // Генерация игрового поля (кувшинки и дыры)
        function generateBoard(numHoles) {
            holes = [];
            let attempts = 0;
            const maxAttempts = GRID_SIZE * GRID_SIZE * 2; // Ограничение попыток, чтобы избежать бесконечного цикла

            while (holes.length < numHoles && attempts < maxAttempts) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                const isOccupied = holes.some(h => h.x === x && h.y === y);

                if (!isOccupied) {
                    holes.push({ x, y });
                }
                attempts++;
            }
        }

        // Размещение жабки в случайном безопасном месте
        function placeFrogRandomly() {
            let placed = false;
            let attempts = 0;
            const maxPlacementAttempts = GRID_SIZE * GRID_SIZE * 2;
            while (!placed && attempts < maxPlacementAttempts) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                // Проверяем, чтобы жабка не появилась в дыре или на хищнике
                if (!holes.some(h => h.x === x && h.y === y) &&
                    !predators.some(p => p.x === x && p.y === y)) {
                    frog.x = x;
                    frog.y = y;
                    placed = true;
                }
                attempts++;
            }
            if (!placed) {
                console.warn("Не удалось разместить жабку в безопасном месте после множества попыток.");
                // В крайнем случае, если не удалось найти безопасное место, размещаем в 0,0
                frog.x = 0;
                frog.y = 0;
            }
        }

        // Размещение мух
        function placeFlies(count) {
            flies = [];
            let attempts = 0;
            const maxAttempts = GRID_SIZE * GRID_SIZE * 2;

            while (flies.length < count && attempts < maxAttempts) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                // Мухи не должны быть в дырах, на жабке или на других мухах/хищниках
                const isOccupied = holes.some(h => h.x === x && h.y === y) ||
                                     (frog.x === x && frog.y === y) ||
                                     flies.some(f => f.x === x && f.y === y) ||
                                     predators.some(p => p.x === x && p.y === y); // Убедимся, что муха не на хищнике
                if (!isOccupied) {
                    flies.push({ x, y });
                }
                attempts++;
            }
        }

        // Размещение хищников
        function placePredators(predatorConfigs) {
            predators = []; // Очищаем массив хищников для нового уровня
            // Для каждого уровня добавляем хищников из текущей конфигурации
            predatorConfigs.forEach(pConfig => {
                for (let i = 0; i < pConfig.count; i++) {
                    let placed = false;
                    let currentAttempts = 0;
                    const maxPlacementAttempts = GRID_SIZE * GRID_SIZE * 2; // Ограничение попыток размещения
                    while (!placed && currentAttempts < maxPlacementAttempts) {
                        const x = Math.floor(Math.random() * GRID_SIZE);
                        const y = Math.floor(Math.random() * GRID_SIZE);
                        // Хищники не должны быть в дырах, на жабке, на мухах или на других хищниках
                        const isOccupied = holes.some(h => h.x === x && h.y === y) ||
                                             (frog.x === x && frog.y === y) ||
                                             flies.some(f => f.x === x && f.y === y) ||
                                             predators.some(p => p.x === x && p.y === y);
                        if (!isOccupied) {
                            predators.push({ x, y, type: pConfig.type }); // Добавляем хищника с его типом
                            placed = true;
                        }
                        currentAttempts++;
                    }
                }
            });
        }

        // Обновление информации на экране
        function updateGameInfo() {
            scoreDisplay.textContent = `Мухи: ${score}`;
            levelDisplay.textContent = `Уровень: ${level}`;
            livesDisplay.textContent = `Жизни: ${frog.lives}`;
        }

        // Отрисовка игрового поля и персонажей
        function draw() {
            // Очищаем холст
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Рисуем кувшинки (зеленые квадратики)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctx.fillStyle = '#9ccc65'; // Светло-зеленый цвет для кувшинок
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = '#8bc34a'; // Темнее зеленый для границ
                    ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // Рисуем дыры
            holes.forEach(hole => {
                ctx.fillStyle = '#42a5f5'; // Синий цвет для воды/дыр
                ctx.fillRect(hole.x * CELL_SIZE, hole.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                // Добавляем эффект "дыры" - темный круг
                ctx.beginPath();
                ctx.arc(hole.x * CELL_SIZE + CELL_SIZE / 2, hole.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
                ctx.fillStyle = '#1e88e5'; // Темно-синий
                ctx.fill();
            });

            // Рисуем мух
            flies.forEach(fly => {
                ctx.font = `${CELL_SIZE * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('🪰', fly.x * CELL_SIZE + CELL_SIZE / 2, fly.y * CELL_SIZE + CELL_SIZE / 2); // Эмодзи мухи
            });

            // Рисуем жабку (используем изображение, если загружено)
            if (isFrogImageLoaded) {
                ctx.drawImage(frogImage, frog.x * CELL_SIZE, frog.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
            // Эмодзи жабки полностью убраны, нет fallback
            
            // Рисуем хищников
            predators.forEach(predator => {
                ctx.font = `${CELL_SIZE * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let emoji;
                switch (predator.type) {
                    case 'snake':
                        emoji = '🐍'; // Эмодзи змеи
                        break;
                    case 'hedgehog':
                        emoji = '🦔'; // Эмодзи ежа
                        break;
                    case 'heron':
                        emoji = '🐦'; // Эмодзи птицы (цапля)
                        break;
                    default:
                        emoji = '❓';
                }
                ctx.fillText(emoji, predator.x * CELL_SIZE + CELL_SIZE / 2, predator.y * CELL_SIZE + CELL_SIZE / 2);
            });
        }

        // Обработка движения жабки
        document.addEventListener('keydown', handleKeyPress);
        // Добавляем обработчики для сенсорных событий (свайпы)
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Предотвращаем прокрутку страницы
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            // Определяем направление свайпа
            if (Math.abs(dx) > Math.abs(dy)) { // Горизонтальный свайп
                if (dx > 0) {
                    moveFrog(0, 1); // Вправо
                } else {
                    moveFrog(0, -1); // Влево
                }
            } else { // Вертикальный свайп
                if (dy > 0) {
                    moveFrog(1, 0); // Вниз
                } else {
                    moveFrog(-1, 0); // Вверх
                }
            }
        });


        function handleKeyPress(e) {
            if (!gameStarted || gameOver) return;

            let newX = frog.x;
            let newY = frog.y;

            switch (e.key) {
                case 'ArrowUp':
                    newY--;
                    break;
                case 'ArrowDown':
                    newY++;
                    break;
                case 'ArrowLeft':
                    newX--;
                    break;
                case 'ArrowRight':
                    newX++;
                    break;
            }
            // Передаем только смещение, функция moveFrog сама вычислит новые координаты
            moveFrog(newY - frog.y, newX - frog.x);
        }

        function moveFrog(dy, dx) {
            if (!gameStarted || gameOver) return;

            let newX = frog.x + dx;
            let newY = frog.y + dy;

            // Проверяем границы поля
            if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                frog.x = newX;
                frog.y = newY;
                checkCollisions();
                draw();
            }
        }

        // Движение хищников
        function movePredators() {
            if (gameOver || !gameStarted) return;

            predators.forEach(predator => {
                let newX = predator.x;
                let newY = predator.y;

                switch (predator.type) {
                    case 'snake':
                        // Змея движется к жабке по одной из координат
                        if (Math.abs(frog.x - predator.x) > Math.abs(frog.y - predator.y)) {
                            newX += (frog.x > predator.x ? 1 : -1);
                        } else {
                            newY += (frog.y > predator.y ? 1 : -1);
                        }
                        break;
                    case 'hedgehog':
                        // Еж движется случайным образом
                        const randomDir = Math.floor(Math.random() * 4);
                        if (randomDir === 0) newY--; // Вверх
                        else if (randomDir === 1) newY++; // Вниз
                        else if (randomDir === 2) newX--; // Влево
                        else if (randomDir === 3) newX++; // Вправо
                        break;
                    case 'heron':
                        // Цапля перемещается на случайную позицию, если не слишком близко к жабке
                        let moved = false;
                        let attempts = 0;
                        const maxAttempts = GRID_SIZE * GRID_SIZE;
                        while (!moved && attempts < maxAttempts) {
                            const randX = Math.floor(Math.random() * GRID_SIZE);
                            const randY = Math.floor(Math.random() * GRID_SIZE);
                            // Цапля не должна прыгать в дыру
                            if (!holes.some(h => h.x === randX && h.y === randY)) {
                                newX = randX;
                                newY = randY;
                                moved = true;
                            }
                            attempts++;
                        }
                        break;
                }

                // Проверяем границы для хищников
                if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                    // Хищники не должны прыгать в дыры
                    if (!holes.some(h => h.x === newX && h.y === newY)) {
                        predator.x = newX;
                        predator.y = newY;
                    }
                }
            });
            checkCollisions();
            draw();
        }

        // Проверка столкновений
        function checkCollisions() {
            // Столкновение с дырой
            if (holes.some(hole => hole.x === frog.x && hole.y === frog.y)) {
                frog.lives--;
                updateGameInfo();
                if (frog.lives <= 0) {
                    endGame('Поражение!', 'Жабка упала в дыру и потеряла все жизни.');
                } else {
                    // Перемещаем жабку в безопасное место
                    placeFrogRandomly();
                }
                // Возвращаемся, чтобы не обрабатывать другие столкновения сразу после падения в дыру
                return;
            }

            // Столкновение с мухой
            const flyIndex = flies.findIndex(fly => fly.x === frog.x && fly.y === frog.y);
            if (flyIndex !== -1) {
                flies.splice(flyIndex, 1); // Удаляем муху
                score++;
                updateGameInfo();
                // Если все мухи на текущем уровне собраны
                if (score >= levelsConfig[level - 1].fliesToEat) { 
                    score = 0; // Сбрасываем счет для нового уровня
                    level++; // Увеличиваем уровень
                    
                    if (level <= levelsConfig.length) {
                        // Если есть следующий уровень, переходим на него
                        showModal('Уровень пройден!', `Отлично! Переход на уровень ${level}!`, () => {
                            loadLevel(level); // Загружаем следующий уровень
                        });
                    } else {
                        // Если прошли все уровни
                        endGame('Победа!', 'Вы прошли все уровни! Вы настоящая жабка-охотница!');
                    }
                    return; // Важно выйти после обработки перехода на новый уровень
                }
            }

            // Столкновение с хищником
            if (predators.some(predator => predator.x === frog.x && predator.y === frog.y)) {
                frog.lives--;
                updateGameInfo();
                if (frog.lives <= 0) {
                    endGame('Поражение!', 'Жабка съедена хищником и потеряла все жизни.');
                } else {
                    // Перемещаем жабку в безопасное место
                    placeFrogRandomly();
                }
                return;
            }
        }

        // Основной игровой цикл (просто вызывает draw, остальная логика в moveFrog и movePredators)
        function gameLoop() {
            if (!gameOver && gameStarted) {
                draw();
                // requestAnimationFrame(gameLoop); // Убрано, так как движение уже управляется событиями/интервалами
            }
        }

        // Завершение игры
        function endGame(title, message) {
            gameOver = true;
            gameStarted = false;
            clearInterval(predatorMovementInterval); // Останавливаем движение хищников
            showModal(title, message, initializeGame); // Предлагаем начать сначала
            startButton.classList.add('hidden'); // Скрываем кнопку "Начать игру"
            resetButton.classList.remove('hidden'); // Показываем кнопку "Перезапустить"
            mainMenuButton.classList.remove('hidden'); // Показываем кнопку "Главное меню"
        }

        // Обработчики кнопок
        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', initializeGame); // Перезапускает игру с начальных настроек
        mainMenuButton.addEventListener('click', initializeGame); // Возвращает к начальному состоянию

        // Инициализация при загрузке страницы и при изменении размера окна
        window.addEventListener('resize', setupCanvasSize);
        initializeGame(); // Инициализация при первом запуске
    </script>
</body>
</html>
